from logging import getLogger

from traits.api import (
    Instance, List, Event, on_trait_change
)

from force_bdss.core.base_model import BaseModel
from force_bdss.core.input_slot_info import InputSlotInfo
from force_bdss.core.output_slot_info import OutputSlotInfo
from force_bdss.core.verifier import VerifierError
from force_bdss.data_sources.i_data_source_factory import IDataSourceFactory
from force_bdss.io.workflow_writer import pop_dunder_recursive


from .data_source_utilities import (
    merge_lists_with_check
)

logger = getLogger(__name__)


class BaseDataSourceModel(BaseModel):
    """Base class for the factory specific DataSource models.
    This model will also provide, through traits/traitsui magic the View
    that will appear in the workflow manager UI.

    In your factory definition, your factory-specific model must reimplement
    this class.
    """
    #: A reference to the creating factory, so that we can
    #: retrieve it as the originating factory.
    factory = Instance(IDataSourceFactory, visible=False, transient=True)

    #: Specifies binding between input slots and source for that value.
    #: Each InputSlotMap instance specifies this information for each of the
    #: slots.
    input_slot_info = List(Instance(InputSlotInfo), visible=False)

    #: Allows to assign names and KPI status to the output slots, so that
    #: they can be referenced somewhere else (e.g. another layer's
    #: DataSources).
    #: If the name is the empty string, it means that the user is not
    #: interested in preserving the information, and should therefore be
    #: discarded and not propagated further.
    output_slot_info = List(Instance(OutputSlotInfo), visible=False)

    #: This event claims that a change in the model influences the slots
    #: (either input or output). It must be triggered every time a specific
    #: option in your model implies a change in the slots. The UI will detect
    #: this and adapt the visual entries.
    changes_slots = Event()

    def __init__(self, factory=None, *args, **kwargs):
        super(BaseDataSourceModel, self).__init__(factory, *args, **kwargs)
        # Perform extra checks on input_slot_info and output_slot_info
        # to make sure they will be accepted by the BaseDataSource associated
        # with factory
        self._assign_slot_info()

    # -------------------
    #      Listeners
    # -------------------

    @on_trait_change("+changes_slots")
    def _trigger_changes_slots(self, obj, name, new):
        changes_slots = self.traits()[name].changes_slots

        if changes_slots:
            self.changes_slots = True

    # -------------------
    #  Protected Methods
    # -------------------

    def __getstate__(self):
        """Formats the return of __getstate__ to remove protected
        attributes and provide a simpler format for input_slot_info
        and output_slot_info attributes"""
        state = pop_dunder_recursive(super().__getstate__())
        state["input_slot_info"] = [
            x.__getstate__() for x in self.input_slot_info
        ]
        state["output_slot_info"] = [
            x.__getstate__() for x in self.output_slot_info
        ]

        return state

    # -------------------
    #   Private Methods
    # -------------------

    def _return_slots(self):
        """Provides iterable return values of slots method on
        BaseDataSource that is generated by the factory attribute"""

        data_source = self.factory.create_data_source()

        try:
            input_slots, output_slots = data_source.slots(self)
        except Exception:
            logger.exception(
                "Unable to retrieve slot information from data source"
                " created by factory {}, plugin {}. This might "
                "indicate a programming error.",
                self.factory.id,
                self.factory.plugin_id
            )
            raise

        return list(input_slots), list(output_slots)

    def _slot_info_generator(self):
        """Generates default lists of InputSlotInfo and
        OutputSlotInfo objects, based on values returned by
        _return_slots method

        Yields
        ------
        element: tuple[str, list of InputSlotInfo or OutputSlotInfo]
            Tuple containing name of trait as first element and
            an object instance that could be assigned to the trait
            as second element
        """

        input_slots, output_slots = self._return_slots()

        input_slot_info = [
            InputSlotInfo(type=slot.type,
                          description=slot.description)
            for slot in input_slots
        ]

        output_slot_info = [
            OutputSlotInfo(type=slot.type,
                           description=slot.description)
            for slot in output_slots
        ]

        for element in zip(["input_slot_info", "output_slot_info"],
                           [input_slot_info, output_slot_info]):
            yield element

    def _assign_slot_info(self):
        """Assign input_slot_info or output_slot_info attributes
        with new values, based on the format of return Slot objects
        from _generate_slot methods.

        Raises
        ------
        ValueError, if length of slot_info and name attribute are not equal
        TraitSimilarityError, if the `type` and `description` attributes
        on each element do not pass a `merge_trait_check` call
        """

        # Get default slot info lists and cycle through each slot_info
        # attribute
        for attr_name, slot_info in self._slot_info_generator():

            attr = getattr(self, attr_name)

            if attr:
                # Check that the length of attr is same as its
                # default value
                if len(attr) != len(slot_info):
                    error_msg = (
                        "The number of {} objects ({}) of the"
                        " {} model doesn't match the expected number "
                        "of slots ({}). This is likely due to a "
                        "corrupted file.".format(
                            type(attr[0]).__name__,
                            len(attr),
                            type(self).__name__,
                            len(slot_info))
                    )
                    logger.exception(error_msg)
                    raise ValueError(error_msg)

                # Perform a merge of `type` and `description`
                # attributes between the corresponding
                # InputSlotInfo/OutputSlotInfo and Slot elements.
                merge_lists_with_check(
                    attr, slot_info,
                    attributes=['type', 'description']
                )
            else:
                # If attribute list is empty, simply assign default
                # value
                setattr(self, attr_name, slot_info)

    # -------------------
    #   Public Methods
    # -------------------

    def verify(self):
        """ Verify the data source model.

        The data source model must have:
        - input and output slots match between instance and model
        - all output slots named
        - no errors in input or output slots

        Returns
        -------
        errors : list of VerifierErrors
            The list of all detected errors in the data source model.
        """

        input_slots, output_slots = self._return_slots()

        errors = []

        if len(input_slots) != len(self.input_slot_info):
            errors.append(
                VerifierError(
                    subject=self,
                    local_error="The number of input slots is incorrect.",
                    global_error=(
                        "A data source model has incorrect number "
                        "of input slots."
                    ),
                )
            )

        for input_slot in self.input_slot_info:
            errors += input_slot.verify()

        if len(output_slots) != len(self.output_slot_info):
            errors.append(
                VerifierError(
                    subject=self,
                    local_error="The number of output slots is incorrect.",
                    global_error=(
                        "A data source model has incorrect number "
                        "of output slots."
                    ),
                )
            )

        if self.output_slot_info and not any(
                output_slot.name for output_slot in self.output_slot_info):
            errors.append(
                VerifierError(
                    subject=self,
                    severity='warning',
                    local_error="All output variables have undefined names.",
                    global_error=(
                        "A data source model has no defined output names."
                    ),
                )
            )
        for output_slot in self.output_slot_info:
            errors += output_slot.verify()

        return errors
