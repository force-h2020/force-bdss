from logging import getLogger

from traits.api import (
    Instance, List, Event, on_trait_change, Property, Tuple, Int
)

from force_bdss.core.base_model import BaseModel
from force_bdss.core.input_slot_info import InputSlotInfo
from force_bdss.core.output_slot_info import OutputSlotInfo
from force_bdss.core.verifier import VerifierError
from force_bdss.data_sources.i_data_source_factory import IDataSourceFactory
from force_bdss.io.workflow_writer import pop_dunder_recursive


logger = getLogger(__name__)


class BaseDataSourceModel(BaseModel):
    """Base class for the factory specific DataSource models.
    This model will also provide, through traits/traitsui magic the View
    that will appear in the workflow manager UI.

    In your factory definition, your factory-specific model must reimplement
    this class.
    """
    #: A reference to the creating factory, so that we can
    #: retrieve it as the originating factory.
    factory = Instance(IDataSourceFactory, visible=False, transient=True)

    #: Specifies binding between input slots and source for that value.
    #: Each InputSlotMap instance specifies this information for each of the
    #: slots.
    input_slot_info = List(Instance(InputSlotInfo), visible=False)

    #: Allows to assign names and KPI status to the output slots, so that
    #: they can be referenced somewhere else (e.g. another layer's
    #: DataSources).
    #: If the name is the empty string, it means that the user is not
    #: interested in preserving the information, and should therefore be
    #: discarded and not propagated further.
    output_slot_info = List(Instance(OutputSlotInfo), visible=False)

    #: This event claims that a change in the model influences the slots
    #: (either input or output). It must be triggered every time a specific
    #: option in your model implies a change in the slots. The UI will detect
    #: this and adapt the visual entries.
    changes_slots = Event()

    def __init__(self, factory=None, input_slot_info=None,
                 output_slot_info=None, *args, **kwargs):
        super(BaseDataSourceModel, self).__init__(factory, *args, **kwargs)

        if input_slot_info is not None:
            self.update_slot_info(
                "input_slot_info", input_slot_info
            )

        if output_slot_info is not None:
            self.update_slot_info(
                "output_slot_info", output_slot_info
            )

    # -------------------
    #      Defaults
    # -------------------

    def _input_slot_info_default(self):
        """Default list of InputSlotInfo object, based on length and
        attributes of Slots tuple returned by slots method on associated
        BaseDataSource"""

        input_slots, _ = self._generate_slots()

        return [
            InputSlotInfo(
                name='', type=slot.type,
                description=slot.description
            )
            for slot in input_slots
        ]

    def _output_slot_info_default(self):
        """Default list of OutputSlotInfo object, based on length and
        attributes of Slots tuple returned by slots method on associated
        BaseDataSource"""
        _, output_slots = self._generate_slots()

        return [
            OutputSlotInfo(
                name='', type=slot.type,
                description=slot.description
            )
            for slot in output_slots
        ]

    # -------------------
    #      Listeners
    # -------------------

    @on_trait_change("+changes_slots")
    def _trigger_changes_slots(self, obj, name, new):
        changes_slots = self.traits()[name].changes_slots

        if changes_slots:
            self._reset_data_source_slots()
            self.changes_slots = True

    # -------------------
    #  Protected Methods
    # -------------------

    def __getstate__(self):
        state = pop_dunder_recursive(super().__getstate__())
        state["input_slot_info"] = [
            x.__getstate__() for x in self.input_slot_info
        ]
        state["output_slot_info"] = [
            x.__getstate__() for x in self.output_slot_info
        ]

        return state

    # -------------------
    #   Private Methods
    # -------------------

    def _generate_slots(self):
        """Returns slots generated by the DataSource associated with the
        assigned factory trait"""

        data_source = self.factory.create_data_source()

        try:
            input_slots, output_slots = data_source.slots(self)
        except Exception:
            logger.exception(
                "Unable to retrieve slot information from data source"
                " created by factory {}, plugin {}. This might "
                "indicate a programming error.",
                self.factory.id,
                self.factory.plugin.id
            )
            raise

        return input_slots, output_slots

    def _reset_data_source_slots(self):
        """Reset input_slot_info and output_slot_info attributes to
        their defaults, based on the return value of a BaseDataSource
        slots method"""

        self.input_slot_info = self._input_slot_info_default()
        self.output_slot_info = self._output_slot_info_default()

    def _sync_slot_info(self, new_info, old_info):
        """Update either an InputSlotInfo or OutputSlotInfo trait with new
        attributes. This occurs in place, so as not to lose the slot type
        and description information returned from associated BaseDataSource.

        Parameters
        ----------
        new_info, old_info: InputSlotInfo, OutputSlotInfo
            Instances of either InputSlotInfo or OutputSlotInfo (must
            be the same type). Attributes on old_info will be overwritten
            in place by those on new_info
        """

        if type(new_info) != type(old_info):
            error_msg = (
                "The argument new_info: {} is not of the same class"
                " as old_info: {}. This is"
                " likely due to a corrupted file.".format(
                    type(new_info), type(old_info)
                )
            )
            logger.exception(error_msg)
            raise RuntimeError(error_msg)

        # If the type attribute on new_info is defined, make sure it
        # matches with the type attribute on old_info
        if new_info.type and old_info.type != new_info.type:
            error_msg = (
                "The type attribute ({}) of slot {} doesn't match the target"
                " type attribute ({}) of slot {}. This is"
                " likely due to a corrupted file.".format(
                    old_info.type, old_info,
                    new_info.type, new_info
                )
            )
            logger.exception(error_msg)
            raise RuntimeError(error_msg)

        old_info.name = new_info.name

    # -------------------
    #   Public Methods
    # -------------------

    def update_slot_info(self, name, slot_info):
        """Update the name trait with new values. The argument
        slot_info must have the same length as the existing class
        trait name.

        Parameters
        ----------
        name: str
            Name of attribute to update, must be either "input_slot_info"
            or "output_slot_info"
        slot_info: list of type InputSlotInfo of OutputSlotInfo
            List containing objects to update each element of
            name attribute with
        """

        # Ignore any changes if slot_info list is empty
        if len(slot_info) == 0:
            return

        if name not in ["input_slot_info", "output_slot_info"]:
            error_msg = (
                "Attribute 'name' must be either 'input_slot_info' "
                "or 'output_slot_info'."
            )
            logger.exception(error_msg)
            raise RuntimeError(error_msg)

        slot_info_attr = getattr(self, name)

        if len(slot_info) != len(slot_info_attr):
            error_msg = (
                "The number of slots in {} ({}) of the {} model doesn't"
                " match the expected number of slots ({}). This is"
                " likely due to a corrupted file.".format(
                    name, len(slot_info_attr),
                    type(self).__name__,
                    len(slot_info))
            )
            logger.exception(error_msg)
            raise RuntimeError(error_msg)

        for new_info, old_info in zip(slot_info, slot_info_attr):
            self._sync_slot_info(new_info, old_info)

    def verify(self):
        """ Verify the data source model.

        The data source model must have:
        - input and output slots match between instance and model
        - all output slots named
        - no errors in input or output slots

        Returns
        -------
        errors : list of VerifierErrors
            The list of all detected errors in the data source model.
        """

        input_slots, output_slots = self._generate_slots()

        errors = []

        if len(input_slots) != len(self.input_slot_info):
            errors.append(
                VerifierError(
                    subject=self,
                    local_error="The number of input slots is incorrect.",
                    global_error=(
                        "A data source model has incorrect number "
                        "of input slots."
                    ),
                )
            )

        for input_slot in self.input_slot_info:
            errors += input_slot.verify()

        if len(output_slots) != len(self.output_slot_info):
            errors.append(
                VerifierError(
                    subject=self,
                    local_error="The number of output slots is incorrect.",
                    global_error=(
                        "A data source model has incorrect number "
                        "of output slots."
                    ),
                )
            )

        if self.output_slot_info and not any(
                output_slot.name for output_slot in self.output_slot_info):
            errors.append(
                VerifierError(
                    subject=self,
                    severity='warning',
                    local_error="All output variables have undefined names.",
                    global_error=(
                        "A data source model has no defined output names."
                    ),
                )
            )
        for output_slot in self.output_slot_info:
            errors += output_slot.verify()

        return errors
