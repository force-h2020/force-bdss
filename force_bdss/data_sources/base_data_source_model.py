from logging import getLogger

from traits.api import (
    Instance, List, Event, on_trait_change
)

from force_bdss.core.base_model import BaseModel
from force_bdss.core.input_slot_info import InputSlotInfo
from force_bdss.core.output_slot_info import OutputSlotInfo
from force_bdss.core.verifier import VerifierError
from force_bdss.data_sources.i_data_source_factory import IDataSourceFactory
from force_bdss.io.workflow_writer import pop_dunder_recursive


logger = getLogger(__name__)


class BaseDataSourceModel(BaseModel):
    """Base class for the factory specific DataSource models.
    This model will also provide, through traits/traitsui magic the View
    that will appear in the workflow manager UI.

    In your factory definition, your factory-specific model must reimplement
    this class.
    """
    #: A reference to the creating factory, so that we can
    #: retrieve it as the originating factory.
    factory = Instance(IDataSourceFactory, visible=False, transient=True)

    #: Specifies binding between input slots and source for that value.
    #: Each InputSlotMap instance specifies this information for each of the
    #: slots.
    input_slot_info = List(Instance(InputSlotInfo), visible=False)

    #: Allows to assign names and KPI status to the output slots, so that
    #: they can be referenced somewhere else (e.g. another layer's
    #: DataSources).
    #: If the name is the empty string, it means that the user is not
    #: interested in preserving the information, and should therefore be
    #: discarded and not propagated further.
    output_slot_info = List(Instance(OutputSlotInfo), visible=False)

    #: This event claims that a change in the model influences the slots
    #: (either input or output). It must be triggered every time a specific
    #: option in your model implies a change in the slots. The UI will detect
    #: this and adapt the visual entries.
    changes_slots = Event()

    def __init__(self, *args, **kwargs):
        super(BaseDataSourceModel, self).__init__(*args, **kwargs)
        self._sync_data_source_slots()

    def _generate_slots(self):
        """Returns slots generated by the DataSource associated with the
        assigned factory trait"""

        try:
            data_source = self.factory.create_data_source()
        except Exception:
            logger.exception(
                "Unable to create data source from factory '%s', plugin "
                "'%s'. This might indicate a  programming error",
                self.factory.id,
                self.factory.plugin.id,
            )
            raise

        try:
            input_slots, output_slots = data_source.slots(self)
        except Exception:
            logger.exception(
                "Unable to retrieve slot information from data source"
                " created by factory '%s', plugin '%s'. This might "
                "indicate a programming error.",
                self.factory.id,
                self.factory.plugin.id
            )
            raise

        return input_slots, output_slots

    @on_trait_change('input_slot_info[],output_slot_info[]', post_init=True)
    def _sync_data_source_slots(self):
        """Checks the length of input_slots and output_slots is the same as
        the input_slot_info and output_slot_info. If so, assigns Slot types
        to InputSlotInfo and OutputSlotInfo instances"""

        input_slots, output_slots = self._generate_slots()

        if len(self.input_slot_info) == 0:
            self.input_slot_info = [
                InputSlotInfo(
                    name='', type=slot.type,
                    description=slot.description
                )
                for slot in input_slots
            ]
        else:
            if len(self.input_slot_info) != len(input_slots):
                error_msg = (
                    "The number of input slots ({}) of the {} model doesn't"
                    " match the expected number of slots ({}). This is"
                    " likely due to a corrupted file.".format(
                        len(self.input_slot_info), type(self).__name__,
                        len(input_slots))
                )
                logger.exception(error_msg)
                raise RuntimeError(error_msg)

            for slot, info in zip(input_slots, self.input_slot_info):
                info.type = slot.type

        if len(self.output_slot_info) == 0:
            self.output_slot_info = [
                OutputSlotInfo(
                    name='', type=slot.type,
                    description=slot.description
                )
                for slot in output_slots
            ]
        else:
            if len(self.output_slot_info) != len(output_slots):
                error_msg = (
                    "The number of output slots ({}) of the {} model doesn't"
                    " match the expected number of slots ({}). This is likely"
                    " due to a corrupted file.".format(
                        len(self.output_slot_info), type(self).__name__,
                        len(output_slots))
                )
                logger.exception(error_msg)
                raise RuntimeError(error_msg)

            for slot, info in zip(output_slots, self.output_slot_info):
                info.type = slot.type

    def verify(self):
        """ Verify the data source model.

        The data source model must have:
        - input and output slots match between instance and model
        - all output slots named
        - no errors in input or output slots

        Returns
        -------
        errors : list of VerifierErrors
            The list of all detected errors in the data source model.
        """

        self._sync_data_source_slots()

        errors = []
        for input_slot in self.input_slot_info:
            errors += input_slot.verify()

        if self.output_slot_info and not any(
                output_slot.name for output_slot in self.output_slot_info):
            errors.append(
                VerifierError(
                    subject=self,
                    severity='warning',
                    local_error="All output variables have undefined names",
                    global_error=(
                        "A data source model has no defined output names"
                    ),
                )
            )
        for output_slot in self.output_slot_info:
            errors += output_slot.verify()

        return errors

    def __getstate__(self):
        state = pop_dunder_recursive(super().__getstate__())
        state["input_slot_info"] = [
            x.__getstate__() for x in self.input_slot_info
        ]
        state["output_slot_info"] = [
            x.__getstate__() for x in self.output_slot_info
        ]

        return state

    @on_trait_change("+changes_slots")
    def _trigger_changes_slots(self, obj, name, new):
        changes_slots = self.traits()[name].changes_slots

        if changes_slots:
            self.changes_slots = True
