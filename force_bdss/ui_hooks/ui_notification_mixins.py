from threading import Event as ThreadingEvent

from traits.api import Instance, HasStrictTraits


class UIEventNotificationMixin(HasStrictTraits):
    """ The UIEventNotificationMixin contains the _stop and _pause
    threading.Event instances, and implements basic API to send the
    stop or pause / resume commands via these events."""

    #: control event that indicates whether the `STOP` signal has been
    #: received by the Listener from the UI
    _stop_event = Instance(ThreadingEvent, visible=False, transient=True)

    #: control event that indicates whether the `PAUSE` / 'RESUME' signal
    #: has been received by the Listener from the UI
    _pause_event = Instance(ThreadingEvent, visible=False, transient=True)

    def set_stop_event(self, event):
        self._stop_event = event

    def set_pause_event(self, event):
        self._pause_event = event

    def send_stop(self):
        # Sends stop event first, in case run is already paused
        self._stop_event.set()

        # In case system is paused, then resume and stop
        self._pause_event.set()

    def send_pause(self):
        self._pause_event.clear()

    def send_resume(self):
        self._pause_event.set()


class UIEventMixin:
    """ This mixin class can be used to indicate an Event that needs to
    be broadcast to any UI that is listening to the BDSS during runtime.

    For example, the UINotificationListener class (found in the force_wfmanager
    package) listens to any BaseDriverEvents generated by the BDSS but only
    delivers those of type UIEventMixin to the WorkflowManager.
    Therefore all events which are not subclasses of UIEventMixin are ignored.
    Additional UI programs can implement a similar system in order to filter
    out messages that need to be reported.

    By default, the MCOStartEvent, MCOProgressEvent and MCOFinishEvent
    classes all inherit from UIEventMixin."""
    pass
